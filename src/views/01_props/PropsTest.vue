<template>
  <div class="box">
    <h1>props:我是父组件曹操</h1>
    <p>props:可以实现父子组件、子父组件、甚至兄弟组件通信</p>
    <hr />
    <!-- <Child info="我是曹操" :money="money" infoVue2="我是曹操vue2传值" :moneyVue2=( money+202 )></Child> -->
    <Child info="我是曹操" :money="money"></Child>
  </div>
</template>

<script setup lang="ts">
//props:可以实现父子组件通信,props数据还是只读的！！！
import Child from './Child.vue'
import { ref } from 'vue'
// ref() 接受一个内部值，返回一个ref 对象，这个对象是响应式的、可更改的，且只有一个指向其内部值的属性 .value。
// ref() 将传入参数的值包装为一个带 .value 属性的 ref 对象。
// ref 对象是可更改的，即可以为 .value 赋予新的值
let money = ref(10000)
money.value = 10001

// 测试 var let声明
for (var i = 0; i < 10; i++) {
  setTimeout(function () {
    console.log('测试一：', i)
  }, 100)
}

for (var i = 0; i < 10; i++) {
  //i=0  第一轮循环
  ;(function (i) {
    // 立即执行函数执行，形成一个私有的函数上下文
    // 形参i是属于立即执行函数的局部变量，第一轮循环时相当于let i=0
    // 由于立即执行函数的参数i被下一级的延时器回调函数上下文所引用，所以会产生闭包，
    // 从而形成块级作用域，保护了每一次循环的i，也就是闭包的特点：变量私有化

    setTimeout(() => {
      // 延时器回调函数执行，也会形成一个私有的函数上下文
      console.log('测试二：', i) //由于当前延时器回调函数上下文引用了
      // 上一级立即执行函数的参数i（立即执行函数的局部变量）,
      //所以此时会产生闭包，立即执行函数的参数i会一直保存在内存中供延时器回调函数使用
    }, 1000)
  })(i) //把每一轮循环全局的i的值作为实参传递给立即执行函数的私有上下文，第一轮传递的是0
}

for (let i = 0; i < 10; i++) {
  // 每一轮都会形成一个私有的块级作用域，并且有一个私有的变量i，分别存储每一轮循环的索引
  // 形成闭包的机制
  setTimeout(function () {
    console.log('测试三：', i)
  }, 1200)
}
</script>

<!-- 
var声明
var 是ES6之前 js用来声明变量的方法
var的作用域是函数作用域，即在一个函数内利用var声明的变量，只在这个函数内有效
1. 使用var声明的变量，这个变量属于当前的函数作用域，如果变量的声明在任何函数外，那么这个变量就属于全局作用域
2.如果在声明变量时，省略 var 的话，该变量就会变成全局变量，如全局作用域中存在该变量，就会更新其值
    var a = 1; //此处声明的变量a为全局变量
    function foo(){
      a = 2;//此处的变量a也是全局变量
      console.log(a);//2
    }
    foo();
3.var存在变量声明提前。js预解析时把var的声明提升到当前作用域的最前面，意思是是指无论 var 出现在
  一个作用域的哪个位置，这个声明都属于当前的整个作用域，在其中到处都可以访问到。
    console.log(a);//undefined
    var a = 1;
    相当于执行以下代码
    var a;
    console.log(a);//undefined
    a = 1;

for (var i = 0; i < 10; i++) {
    setTimeout(function(){
      console.log(i);
    },100)
};
1.此时的var声明的变量i属于函数作用域，声明又不在函数里，所以i属于全局变量
2.此时的定时器函数属于异步函数，隔100毫秒才会执行，而这100毫秒的时间内，for循环
  已经循环结束，全局变量i已经为10
3.var声明的变量i没有块级作用域，所以每次循环都可以访问第一次循环体内的变量i
4.最后代码的执行后，会在控制台打印出10个10

***使用闭包原理解决上例中var声明变量的不具有块级作用域的问题：
for (var i=0; i<10; i++) {
  //i=0  第一轮循环
  (function (i) {
    // 立即执行函数执行，形成一个私有的函数上下文
    // 形参i是属于立即执行函数的局部变量，第一轮循环时相当于let i=0
    // 由于立即执行函数的参数i被下一级的延时器回调函数上下文所引用，所以会产生闭包，
    // 从而形成块级作用域，保护了每一次循环的i，也就是闭包的特点：变量私有化

    setTimeout(() => {
      // 延时器回调函数执行，也会形成一个私有的函数上下文
      console.log(i);//由于当前延时器回调函数上下文引用了
      // 上一级立即执行函数的参数i（立即执行函数的局部变量）,
      //所以此时会产生闭包，立即执行函数的参数i会一直保存在内存中供延时器回调函数使用
    }, 5000)
  })(i)//把每一轮循环全局的i的值作为实参传递给立即执行函数的私有上下文，第一轮传递的是0
}
========================================================================

let声明
  let是ES6中的新特性
  let的作用域是块级作用域（在ES6之前，js只存在函数作用域以及全局作用域）
  let不存在变量声明提前
  let不能重复定义
  let存在暂时性死区
扩展：块级作用域：
① 在一个块级作用域中，变量唯一存在，一旦在块级作用域中用let声明了一个变量，那么这个变量就唯一属于这个块级作用域，不受外部变量的影响；
② 无论在块中的任何地方声明了一个变量，那么在这个块级作用域中，任何使用这个名字的变量都是指这个变量，无论外部是否有其他同名的全局变量；
③ 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
④ 暂时性死区的意义：让我们标准化代码。将所有的变量的声明放在作用域的最开始。

for (let i = 0; i < 10; i++) {
    // 每一轮都会形成一个私有的块级作用域，并且有一个私有的变量i，分别存储每一轮循环的索引
    // 形成闭包的机制
    setTimeout(function(){
      console.log(i);
    },100)
};
// let的块作用域是浏览器底层机制实现的，比我们自己创建的闭包性能要好一些

========================================================================
var 和 let 在函数作用域中声明一个变量，两个变量的意义是相同的。
在块作用域中两者的区别较为明显， let只在for()循环中可用，而 var是对于包围for循环的整个函数可用
function aFun1() {
  for (let i = 1; i < 5; i++) {
    // i只有在这里是可见的
    console.log(i);
  }
  // i 对于for循环外的范围是不可见的(i is not defined)
  // console.log(i);
}

function aFun2() {
  for (var i = 1; i < 5; i++) {
    // i 在for 在整个函数体内都是可见的
    console.log(i);
  }
  // i 对于for循环外的范围是可见的
  console.log(i);
}
aFun2();
aFun1();
========================================================================

const 声明
1.const 声明方式，除了具有 let 的上述特点外，其还具备一个特点，即 const 定义的变量，
一旦定义后，就不能修改，即 const 声明的为常量。
2.但是，并不是说 const 声明的变量其内部内容不可变，如：
    const obj = {a:1,b:2};
    console.log(obj.a);//1
    obj.a = 3;
    console.log(obj.a);//3
即：如果是简单数据类型，const声明的变量保存的值就是变量的值，是不可以修改，但如果是复杂
数据类型(对象，数组等）const只是保存的是复杂数据类型的地址，只是确保地址不可变，但地址
指向的内容是可以变的。

let和const是es6的新特性，let和const的出现就是为了解决var的各种问题，
强烈建议大家写js代码都用let和const声明变量和常量
-->

<!-- 当style标签里面有scoped属性时，它的css只作用于当前组件的元素。在单页面项目中
  可以使组件之间互不污染，实现模块化，实现组件的私有化，不对全局造成样式污染，
  表示当前style属性只属于当前模块。
  注意：实际开发中建议在每个组件的 style 身上都加上 scoped 属性。
 -->
<style scoped>
.box {
  /* vm的意思是Viewport Units的简称，表达的是视口单位。视口指的是用户在浏览器中查看
  网页时的区域，也就是可见区域。1vm等于可视区域宽度的1/100，也就是1%。
  在电脑端使用VM作为单位有很多好处。首先，它可以让网页在不同尺寸的显示器上，显示出大
  致相同的效果。
  VM这种视口单位是很重要的一种CSS单位。它的弹性和相对优势使得它比其他单位更符合移动
  端/电脑端自适应布局的需求。 */
  width: 90vw;
  height: 400px;
  background: yellowgreen;
}
</style>
